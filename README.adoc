---
tags: [spring-cloud, config server]
projects: [spring-cloud, spring-cloud-config]
---
:toc:
:icons: font
:source-highlighter: prettify
:project_id: gs-centralized-configuration

本指南将带你了解从建立 http://cloud.spring.io/spring-cloud-config/spring-cloud-config.html[Spring Cloud Config Server]并从中获取配置的过程。

== 你构建什么

你会建立一个配置服务器，然后建立一个客户端在启动的时候获取配置，然后 _refreshes_ 配置而无需重新启动客户端。

== 你需要什么

:java_version: 1.8
include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/prereq_editor_jdk_buildtools.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/how_to_complete_this_guide.adoc[]

[[reveal-gradle]]
[.reveal-gradle]
== Build with Gradle

[[scratch]]
[.use-gradle]
== Build with Gradle

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_both_builds.adoc[]

`configuration-service/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/configuration-service/build.gradle[]
----

`configuration-client/build.gradle`
// AsciiDoc source formatting doesn't support groovy, so using java instead
[source,java]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/configuration-client/build.gradle[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-gradle-plugin.adoc[]

[[reveal-maven]]
[.reveal-maven]
== Build with Maven

[[use-maven]]
[.use-maven]
== Build with Maven

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/build_system_intro_maven.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/create_directory_structure_hello.adoc[]

为了快速启动，这里是服务器和客户端应用程序的完整配置：

`configuration-service/pom.xml`
[source,xml]
----
include::https://raw.githubusercontent.com/spring-guides/{project_id}/master/initial/configuration-service/pom.xml[]
----

`configuration-client/pom.xml`
[source,xml]
----
include::https://raw.githubusercontent.com/webGoBetter/{project_id}/master/initial/configuration-client/pom.xml[]
----

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/spring-boot-maven-plugin.adoc[]

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/hide-show-sts.adoc[]


[[initial]]
== 启动配置服务器
您首先需要一个配置服务，充当Spring应用程序和典型的版本控制的配置文件存储库之间的中介。你可以用Spring Cloud的 `@EnableConfigServer` 建立一个配置服务器，这样其他应用程序可以与它沟通。这是一个普通的Spring Boot应用，添加了一个注解，为了 _enable_ 配置服务器。

`configuration-service/src/main/java/hello/ConfigServiceApplication.java`
[source,java]
----
include::complete/configuration-service/src/main/java/hello/ConfigServiceApplication.java[]
----

配置服务器需要知道要管理哪个存储库。这里有几种选择，但我们将使用基于Git的文件系统存储库。你也可以将配置服务器指向GitHub或gitlab库。在文件系统上，创建一个新的目录然后在这个目录下运行 `git init` 。然后添加一个名为 `a-bootiful-client.properties` 的文件到Git仓库。确保 `git commit` 提交了它。不久，你将连接到一个Spring Boot应用的配置服务器。它的 `spring.application.name` 属性标志它对配置服务器来说，是一个 `a-bootiful-client` 。这就是配置服务器如何知道要发送给特定客户机的哪一组配置。它 _也_ 将发送任何在git仓库找到的文件名为 `application.properties` 或 `application.yml` 的值。具体命名的文件（如 `a-bootiful-client.properties`）属性键会重写那些 `application.properties` 或 `application.yml` 。

添加一个简单的属性和值, `message = Hello world`, 到刚创建的 `a-bootiful-client.properties` 文件，然后 `git commit` 这些更改.

通过指定 `configuration-service/src/main/resources/application.properties`文件中的 `spring.cloud.config.server.git.uri` 属性来执行Git仓库的路径。确保在同一台机器上同时运行此服务器和另一个Spring Boot应用程序时，指定一个不同 `server.port` 值，以避免端口冲突。

`configuration-service/src/main/resources/application.properties`
[source,properties]
----
include::complete/configuration-service/src/main/resources/application.properties[]
----


== 使用配置客户端从配置服务器读取配置

现在我们已经建立了一个配置服务器，让我们建立一个新的Spring Boot应用程序,使用配置服务器加载自己的配置，根据需求 _刷新_ 它的配置以反映配置服务器上的的变化，而无需重新启动JVM。为了连接到配置服务器，添加 `org.springframework.cloud:spring-cloud-starter-config` 依赖。Spring会发现配置属性文件，和从 `application.properties` 或 `application.yml` 或任何其他 `PropertySource` 加载的一样。

The properties to configure the  Config Client must necessarily be read in _before_ the rest of the application's configuration is read from the Config Server, during the _bootstrap_ phase. Specify the client's `spring.application.name` as `a-bootiful-client` and the location of the Config Server `spring.cloud.config.uri` in `configuration-client/src/main/resources/bootstrap.properties`, where it will be loaded earlier than any other configuration.


`configuration-client/src/main/resources/bootstrap.properties`
[source,java]
----
include::complete/configuration-client/src/main/resources/bootstrap.properties[]
----


The client may access any value in the Config Server using the traditional mechanisms (e.g. `@ConfigurationProperties`, `@Value("${...}")` or through the `Environment` abstraction). Create a Spring MVC REST controller that returns the resolved `message` property's value. Consult the https://spring.io/guides/gs/rest-service/[Building a RESTful Web Service] guide to learn more about building REST services with Spring MVC and Spring Boot.

By default, the configuration values are read on the client's startup, and not again. You can force a bean to _refresh_ its configuration - to pull updated values from the Config Server - by annotating the `MessageRestController` with the Spring Cloud Config `@RefreshScope` and then by triggering a _refresh_ event.

`configuration-client/src/main/java/hello/ConfigClientApplication.java`
[source,java]
----
include::complete/configuration-client/src/main/java/hello/ConfigClientApplication.java[]
----

== Test the application

Test the end-to-end result by starting the Config Service first and then, once loaded, starting the client. Visit the client app in the browser, `http://localhost:8080/message`. There, you should see the String `Hello world` reflected in the response.

Change the `message` key in the `a-bootiful-client.properties` file in the Git repository to something different (`Hello Spring!`, perhaps?). You can confirm that the Config Server sees the change by visiting `http://localhost:8888/a-bootiful-client/default`. You need to invoke the `refresh` Spring Boot Actuator endpoint in order to force the client to refresh itself and draw the new value in. Spring  Boot's Actuator  exposes operational endpoints, like health checks and environment information, about an application. In order to use it you must add `org.springframework.boot:spring-boot-starter-actuator` to the client app's CLASSPATH. You can invoke the  `refresh` Actuator endpoint by sending an empty HTTP `POST` to the client's `refresh` endpoint, `http://localhost:8080/refresh`, and then confirm it worked by reviewing the `http://localhost:8080/message` endpoint.

NOTE: we set `management.security.enabled=false` in the client app to make this easy to test (by default since Spring Boot 1.5 the Actuator endpoints are secure by default). By default you can still access them over JMX if you don't set the flag.


== Summary
Congratulations! You've just used Spring to centralize configuration for all your services by first standing up a  and to then dynamically update configuration.

include::https://raw.githubusercontent.com/webGoBetter/getting-started-macros/master/footer.adoc[]
